[
  {
    "title": "Abstract: Unit 2 Lab 2C - Estimating Probabilities through Simulation",
    "body": "Unit 2 Lab 2C, titled 'Which Song Plays Next?', introduces students to estimating probabilities using computer simulations in R. Building on previous labs that focused on summarizing data, this lab shifts to understanding and calculating the probability of a specific event. The core task involves estimating the probability of selecting a rap song from a playlist containing 39 rap and 61 rock songs. Students learn to simulate a playlist, perform random selections with replacement, and calculate proportions over many trials (up to 500). The lab emphasizes that while exact probabilities can sometimes be calculated, simulations are invaluable for more complex scenarios. Key R functions like `rep()`, `c()`, `sample()`, `do()`, and `tally()` are used. The concept of `set.seed()` is also introduced to ensure reproducibility of random outcomes. Through practical exercises, students discover how increasing the number of simulation repeats improves the accuracy and reduces the variability of probability estimates."
  },
  {
    "title": "Unit 2 Lab 2C: Estimating Song Selection Probability",
    "body": "Unit 2 Lab 2C, 'Which Song Plays Next?', focuses on estimating the probability that a rap song will be chosen from a playlist. This lab builds upon previous exercises in Unit 2 where students learned to summarize data using measures of center, shape, and spread. Here, the objective shifts to understanding probability through practical application. The playlist for this exercise consists of 100 songs, specifically 39 rap songs and 61 rock songs. The central question students will address is how to estimate the likelihood of a rap song being selected at random from this mixed genre playlist."
  },
  {
    "title": "Simulation Methodology: Random Sampling with Replacement",
    "body": "To estimate the probability in Unit 2 Lab 2C, a specific simulation methodology is employed: random sampling with replacement. Students are asked to imagine selecting a song at random from a playlist, noting its genre (either 'rock' or 'rap'), and then crucially, *returning the song to the playlist* before making the next selection. This process is repeated 499 more times, totaling 500 selections. The statistical investigative question that guides this experiment is: 'On average, what proportion of our selections will be rap?' The act of replacing the song is vital to ensure that each selection is an independent event and the probability of drawing a specific genre remains constant throughout the simulation."
  },
  {
    "title": "The Role of 'Replacement' in Probability Simulations (Question 1 & 2)",
    "body": "A critical aspect of the probability estimation simulation in Unit 2 Lab 2C is the instruction to 'put a song back' after each selection. This practice is known as sampling with replacement. The reason for this is to ensure that the conditions of the experiment remain constant for every draw; specifically, the total number of songs and the number of songs of each genre available for selection do not change. If a song were not put back (sampling without replacement), the probabilities for subsequent draws would change, making each draw dependent on the previous ones. This would significantly alter the nature of the experiment and the interpretation of the resulting proportions, preventing an accurate estimation of the initial probability."
  },
  {
    "title": "Understanding Probability: Definition and Exact Calculation",
    "body": "In Unit 2 Lab 2C, students review the fundamental definition of probability: it is the long-run proportion of time an event occurs. Many probabilities, especially for simple scenarios, can be calculated precisely using basic arithmetic. For instance, given a playlist of 100 songs with 39 rap songs and 61 rock songs, the exact probability of drawing a single rap song is straightforward: 39/100, which can also be expressed as 0.39 or 39%. This exact probability represents what would happen if one were to repeatedly select a song, replace it, and continue this process indefinitely, or 'forever'."
  },
  {
    "title": "Justification for Probability Estimation through Simulations",
    "body": "Unit 2 Lab 2C addresses a crucial question: why estimate a probability when the exact answer (e.g., 39%) is known? The justification lies in the utility of simulations for more complex problems. While simple probabilities can be calculated directly, many real-world scenarios involve probabilities that are too challenging or impossible to compute with simple division. In such cases, programming a computer to run an experiment—a 'simulation'—becomes a powerful tool to estimate the probability. The techniques learned in this lab, even with a simple example, are transferable to very hard and complex probability calculations, where the estimated probability will closely approximate the actual probability."
  },
  {
    "title": "Simulations: Mimicking Reality with Randomness and Computers",
    "body": "Simulations are introduced in Unit 2 Lab 2C as a method to mimic real-life scenarios using the power of randomness and computers. This approach allows students to conduct virtual experiments to estimate probabilities. Before starting the song-picking simulation, it's necessary to create a digital representation of the playlist within the R programming environment. This involves simulating the 39 rap songs and 61 rock songs. The foundational principle is that the output of these computer-driven experiments, when conducted with sufficient repetitions, provides reliable estimates that are very close to the actual probabilities, regardless of the complexity of the underlying problem."
  },
  {
    "title": "Setting Up the Playlist in R: Simulating Rap Songs",
    "body": "To begin the simulation in Unit 2 Lab 2C, students first need to create the playlist in R. This involves representing the 39 rap songs. The `rep()` function in R is utilized for this purpose, which repeats a given value a specified number of times. The code `rap <- rep(\"rap\", times = 39)` effectively creates a vector named `rap` containing 39 instances of the string 'rap'. After running this line, students can verify the creation of this vector by looking in the RStudio 'Environment' pane, ensuring that the `rap` vector is correctly populated and ready to be combined with the rock songs."
  },
  {
    "title": "Constructing the Full Playlist in R: Combining Genres",
    "body": "Following the simulation of individual genres, Unit 2 Lab 2C guides students to combine the simulated rap and rock songs into a single playlist. The `c()` function in R is used for this purpose, which concatenates vectors or values. Students are prompted to complete the code `songs <- c(rap, ____)` to combine their previously created `rap` vector with a similarly created `rock` vector. Once combined, the `songs` vector will represent the complete playlist of 100 songs (39 rap, 61 rock). Typing `songs` into the R console and hitting enter allows students to view the individual song entries and confirm the successful creation of their digital playlist."
  },
  {
    "title": "Random Sampling of Songs in R with `sample()`",
    "body": "In Unit 2 Lab 2C, the act of randomly choosing songs from the created playlist is called 'sampling,' a fundamental concept in data science. R provides the `sample()` function for this purpose. The code `sample(songs, size = 1, replace = TRUE)` demonstrates how to draw a single song from the `songs` playlist. Key parameters are `songs` (the data source), `size = 1` (indicating one selection), and `replace = TRUE` (signifying that the song is put back after selection, which is crucial for maintaining constant probabilities, as discussed earlier). Students are instructed to run this code multiple times to observe the random outcomes and prepare for calculating proportions."
  },
  {
    "title": "Defining and Calculating Proportions from Sample Data",
    "body": "Unit 2 Lab 2C includes a 'Vocabulary Check' to clarify the term 'proportion.' A proportion is defined as a fraction of the whole. For example, if during the simulation, 2 rap songs were drawn out of 10 total selections, the proportion of rap songs would be 2/10. It is common practice to express proportions as a decimal (e.g., 0.20) or even more frequently as a percentage (e.g., 20%). Students are asked to run the sampling code 10 times and then compute this proportion, providing a hands-on understanding of how observed frequencies translate into proportional estimates from their samples."
  },
  {
    "title": "Automating Repeated Simulations with R's `do()` Function",
    "body": "Instead of manually running the `sample()` code multiple times, Unit 2 Lab 2C introduces a more efficient method using R's `do()` function. This function allows for the execution of a block of code a specified number of times, automating the repetitive sampling process. For instance, to perform the song selection 50 times, students would fill in the blanks to create `do(50) * sample(songs, size = 1, replace = TRUE)`. This greatly speeds up the simulation, enabling a larger number of trials than manual execution. It's also emphasized that these results need to be stored in a variable, such as `draws`, for subsequent analysis."
  },
  {
    "title": "Analyzing Simulation Outcomes: Tallying and Computing Proportions",
    "body": "After performing multiple song selections using `do()`, Unit 2 Lab 2C guides students on how to analyze the collected data. The results, stored in a variable like `draws`, can be inspected using `View(draws)`. To summarize the frequency of each genre selected, the `tally()` function is employed. Students fill in the blank `tally(~___, data = draws)` to count how often each genre appeared in their 50 draws. Following this, they compute the proportion of 'rap' songs from these 50 draws. This step reinforces the concept of observed proportions and allows for comparison of variability when drawing 50 songs versus 10 songs, further illustrating the impact of sample size."
  },
  {
    "title": "Proportions as Estimates of Theoretical Probability",
    "body": "Unit 2 Lab 2C highlights the crucial distinction between the observed 'proportions' calculated from simulations and the 'theoretical probability.' The proportions derived from repeated song draws are considered *estimates* of the true theoretical probability of choosing a rap song. A significant insight from the lab is that as the number of draws (or repeats) in a simulation increases, the *range* of these estimated proportions should decrease. This means the estimates become less variable and more consistently close to the actual probability. Therefore, when using simulations, a large number of repetitions is always preferred to achieve more confident and accurate probability estimates."
  },
  {
    "title": "Improving Estimate Accuracy: The Advantage of More Repeats",
    "body": "A key takeaway from Unit 2 Lab 2C regarding simulation accuracy is that increasing the number of repetitions (draws) is beneficial. The text explicitly states: 'When using simulations to estimate probabilities, using a large number of repeats is better because the estimates have less variability and so we can be confident we're closer to the actual value.' This principle explains why students are asked to conduct 500 simulations eventually, rather than just 10 or 50. More trials lead to a narrower range of estimated proportions among different experiments, providing a more stable and reliable approximation of the true underlying probability, which in this case is 39%."
  },
  {
    "title": "Ensuring Reproducibility: The `set.seed()` Function",
    "body": "Unit 2 Lab 2C introduces `set.seed()` to address the inherent variability of random simulations. While randomness produces different outcomes, there are instances where consistent 'random' events are desired, especially for reproducibility or collaborative work. The `set.seed()` function allows users to set a starting point for R's random number generator. If the same seed number is used, the sequence of 'random' numbers generated will be identical, leading to identical simulation outcomes. For example, `set.seed(123); sample(songs, size = 1, replace = TRUE)` will consistently yield 'rap' as the first draw, demonstrating how `set.seed()` removes the variability from the random process for a given sequence."
  },
  {
    "title": "Collaborative Simulations with `set.seed()`",
    "body": "Unit 2 Lab 2C provides a practical exercise for students to experiment with `set.seed()` alongside a partner. Both partners are instructed to choose the same number for `set.seed(___)` before running a simulation of 50 song draws. This exercise demonstrates that using an identical seed value ensures that both partners will obtain the exact same sequence of 'random' selections and, consequently, the same proportion of 'rap' songs. Subsequently, by having partners choose different numbers for `set.seed(___)` for another 50 simulations, the lab illustrates that different seed values lead to different sequences of 'random' numbers and thus different simulation outcomes and proportions, highlighting the impact of the seed choice."
  },
  {
    "title": "Independent Application: Estimating Student Movie Attendance Probability",
    "body": "Unit 2 Lab 2C culminates with an independent practice problem, allowing students to apply all learned simulation techniques. The scenario involves a school with 1,200 students: 400 went to the movies, 600 went to the park, and the rest (200) read at home. The task is to estimate the probability that a randomly chosen student went to the movies last Friday. Students are required to write and run R code to estimate this probability using 500 simulations. Critically, they must include `set.seed(123)` in their code before performing the repeated samples, ensuring reproducibility of their results as part of the assignment. This exercise solidifies their understanding of setting up, running, and documenting a probability simulation."
  },
  {
    "title": "Recap of Unit 2 Lab 2C Core Concepts",
    "body": "Unit 2 Lab 2C provided a comprehensive introduction to probability estimation through simulation. Students learned to represent a real-world scenario—a music playlist—digitally in R. They practiced repeatedly drawing items from this simulated playlist, noting their characteristics (genre), and ensuring replacement to maintain consistent probabilities. A key analytical step involved computing the proportion of a specific characteristic (e.g., 'rap' songs) within their draws. These calculated proportions serve as empirical estimates of the theoretical probability. The lab underlined that these estimates become more reliable and less variable as the number of simulation repetitions increases, moving closer to the true probability."
  },
  {
    "title": "The Value of Simulations for Complex Probability Scenarios",
    "body": "While Unit 2 Lab 2C uses a simple probability (39/100) that can be calculated exactly, it serves to illustrate the fundamental power of simulations. The true value of simulations becomes apparent when probabilities are too complex to be solved with straightforward mathematical formulas. In such advanced cases, a well-designed computer experiment can provide highly accurate estimates. This lab teaches a versatile technique that can be applied across a spectrum of difficulty, from elementary calculations to sophisticated probabilistic models. The estimated probabilities derived from these simulations are consistently very close to the actual probabilities, validating the simulation approach."
  },
  {
    "title": "Practical R Commands for Playlist Creation",
    "body": "To successfully conduct the probability simulation in Unit 2 Lab 2C, students must first set up their digital playlist in R. This involves two core R functions. The `rep()` function is used to create vectors for each genre: for example, `rap <- rep(\"rap\", times = 39)` generates 39 instances of 'rap'. Similarly, `rock <- rep(\"rock\", times = 61)` would create 61 instances of 'rock'. Once these individual genre vectors are ready, the `c()` (combine) function is used to merge them into a single comprehensive playlist vector: `songs <- c(rap, rock)`. This sequence of commands ensures the simulation environment accurately reflects the problem's starting conditions."
  },
  {
    "title": "Executing Random Draws and Initial Proportion Calculations",
    "body": "Unit 2 Lab 2C demonstrates the execution of random draws from the simulated playlist using the `sample()` function. A single draw, `sample(songs, size = 1, replace = TRUE)`, mimics picking one song and putting it back. Students perform this manually several times (e.g., 10 times) to get a feel for the random process. After these initial draws, they compute the proportion of 'rap' songs observed. This hands-on step is crucial for understanding how individual random events contribute to an observed proportion, laying the groundwork for appreciating why a larger number of repetitions (simulations) leads to more stable and accurate estimates of the underlying probability."
  },
  {
    "title": "Leveraging `do()` for Enhanced Simulation Efficiency and Analysis",
    "body": "Unit 2 Lab 2C emphasizes efficiency in simulations by introducing the `do()` function, allowing students to perform many repetitions without manual intervention. For example, `draws <- do(50) * sample(songs, size = 1, replace = TRUE)` executes the sampling 50 times and stores all results. Analyzing these results typically involves the `tally()` function, like `tally(~genre, data = draws)`, to summarize the frequency of selected genres. This process allows students to compare the proportion of 'rap' songs from 50 draws to their earlier 10-draw proportion, observing how the *range* of proportions across the class might shrink with more data, reinforcing the principle that more repeats yield better estimates."
  },
  {
    "title": "The Mechanism and Benefits of `set.seed()` in R",
    "body": "The `set.seed()` function, introduced in Unit 2 Lab 2C, plays a vital role in controlling the 'randomness' of R's functions. By providing an integer argument, `set.seed()` initializes R's pseudo-random number generator to a specific state. This means that if the same seed is used, any subsequent calls to random functions (like `sample()`) will produce the exact same sequence of results. This feature is incredibly useful for debugging code, ensuring reproducibility of research, and facilitating collaborative exercises, as demonstrated in the lab where partners use the same seed to achieve identical simulation outcomes. It transforms seemingly unpredictable random processes into consistent, verifiable experiments."
  },
  {
    "title": "Final Simulation Challenge: Applying All Learned Concepts",
    "body": "The 'On your own' section of Unit 2 Lab 2C serves as a comprehensive assessment of the skills acquired. Students must conceptualize a new probability problem (students attending movies), simulate the underlying population, perform a specified number of random draws (500 simulations), and then estimate the target probability. Crucially, they are directed to use `set.seed(123)` before their `do()` loop. This ensures that their final probability estimate is reproducible and consistent, demonstrating their ability to not only run simulations but also manage the randomness for reliable and verifiable results, echoing the scientific rigor often needed in statistical analysis."
  }
]